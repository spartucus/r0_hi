// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use anyhow::{anyhow, Error, Result};
use ark_bn254::{Bn254, G1Projective};
use ark_groth16::{Groth16, PreparedVerifyingKey, Proof};
use ark_serialize::{CanonicalDeserialize, CanonicalSerialize};
use methods::{HELLO_GUEST_ELF, HELLO_GUEST_ID};
use risc0_binfmt::Digestible;
use risc0_groth16::{
    fr_from_hex_string, g1_from_bytes, g2_from_bytes, split_digest, Seal,
    Verifier as Risc0Groth16Verifier,
};
use risc0_zkp::{core::digest::Digest, verify::VerificationError};
use risc0_zkvm::{
    default_prover, sha, ExecutorEnv, InnerReceipt, ProverOpts, Receipt, VerifierContext,
};

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // An executor environment describes the configurations for the zkVM
    // including program inputs.
    // An default ExecutorEnv can be created like so:
    // `let env = ExecutorEnv::builder().build().unwrap();`
    // However, this `env` does not have any inputs.
    //
    // To add guest input to the executor environment, use
    // ExecutorEnvBuilder::write().
    // To access this method, you'll need to use ExecutorEnv::builder(), which
    // creates an ExecutorEnvBuilder. When you're done adding input, call
    // ExecutorEnvBuilder::build().

    // For example:
    let input: u32 = 15 * u32::pow(2, 27) + 1;
    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    let prove_info = prover
        .prove_with_opts(env, HELLO_GUEST_ELF, &ProverOpts::groth16())
        .unwrap();

    // extract the receipt.
    let receipt = prove_info.receipt;

    // TODO: Implement code for retrieving receipt journal here.

    // For example:
    let output: u32 = receipt.journal.decode().unwrap();
    println!("output: {}", output);

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    receipt.verify(HELLO_GUEST_ID).unwrap();

    println!("receipt verify succeed");

    let artifact = extract_verifier(&receipt);
    println!("extract groth16: {}", artifact.is_ok());

    if artifact.is_ok() {
        let ret = groth16_verify(&artifact.unwrap());
        println!("verify: {}", ret.is_ok());
    }
}

#[derive(Clone, Debug)]
struct Artifact {
    /// prepared verifying key little endian encoded.
    encoded_pvk: Vec<u8>,
    /// proof little endian encoded.
    encoded_proof: Vec<u8>,
    /// prepared public inputs little endian encoded.
    encoded_prepared_inputs: Vec<u8>,
}

fn extract_verifier(receipt: &Receipt) -> Result<Artifact, VerificationError> {
    let ctx = VerifierContext::default();
    let params = ctx
        .groth16_verifier_parameters
        .as_ref()
        .ok_or(VerificationError::VerifierParametersMissing)?;

    if let InnerReceipt::Groth16(inner) = &receipt.inner {
        let (a0, a1) =
            split_digest(params.control_root).map_err(|_| VerificationError::ReceiptFormatError)?;
        let (c0, c1) = split_digest(inner.claim.digest::<sha::Impl>())
            .map_err(|_| VerificationError::ReceiptFormatError)?;
        let mut id_bn554: Digest = params.bn254_control_id;
        id_bn554.as_mut_bytes().reverse();
        let id_bn254_fr = fr_from_hex_string(&hex::encode(id_bn554))
            .map_err(|_| VerificationError::ReceiptFormatError)?;

        let verifier = Risc0Groth16Verifier::new(
            &Seal::from_vec(&inner.seal).map_err(|_| VerificationError::ReceiptFormatError)?,
            &[a0, a1, c0, c1, id_bn254_fr],
            &params.verifying_key,
        )
        .map_err(|_| VerificationError::ReceiptFormatError)?;

        Ok(Artifact {
            encoded_pvk: verifier.encoded_pvk,
            encoded_proof: verifier.encoded_proof,
            encoded_prepared_inputs: verifier.encoded_prepared_inputs,
        })
        
        // Ok(verifier)
    } else {
        return Err(VerificationError::ReceiptFormatError);
    }
}

fn save_artifact(artifact: &Artifact) {}

fn groth16_verify(artifact: &Artifact) -> Result<(), Error> {
    let pvk = &PreparedVerifyingKey::deserialize_uncompressed(&*artifact.encoded_pvk)
        .map_err(|err| anyhow!(err))?;
    let proof =
        &Proof::deserialize_uncompressed(&*artifact.encoded_proof).map_err(|err| anyhow!(err))?;
    let prepared_inputs =
        &G1Projective::deserialize_uncompressed(artifact.encoded_prepared_inputs.as_slice())
            .map_err(|err| anyhow!(err))?;
    match Groth16::<Bn254>::verify_proof_with_prepared_inputs(pvk, proof, prepared_inputs)
        .map_err(|err| anyhow!(err))?
    {
        true => Ok(()),
        false => Err(anyhow!("Invalid proof")),
    }
}
