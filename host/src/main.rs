// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{HELLO_GUEST_ELF, HELLO_GUEST_ID};
use risc0_binfmt::Digestible;
use risc0_groth16::{fr_from_hex_string, split_digest, Seal, Verifier as Groth16Verifier};
use risc0_zkp::{core::digest::Digest, verify::VerificationError};
use risc0_zkvm::{
    default_prover, sha, ExecutorEnv, InnerReceipt, ProverOpts, Receipt, VerifierContext,
};

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // An executor environment describes the configurations for the zkVM
    // including program inputs.
    // An default ExecutorEnv can be created like so:
    // `let env = ExecutorEnv::builder().build().unwrap();`
    // However, this `env` does not have any inputs.
    //
    // To add guest input to the executor environment, use
    // ExecutorEnvBuilder::write().
    // To access this method, you'll need to use ExecutorEnv::builder(), which
    // creates an ExecutorEnvBuilder. When you're done adding input, call
    // ExecutorEnvBuilder::build().

    // For example:
    let input: u32 = 15 * u32::pow(2, 27) + 1;
    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    let prove_info = prover
        .prove_with_opts(env, HELLO_GUEST_ELF, &ProverOpts::groth16())
        .unwrap();

    // extract the receipt.
    let receipt = prove_info.receipt;

    // TODO: Implement code for retrieving receipt journal here.

    // For example:
    let output: u32 = receipt.journal.decode().unwrap();
    println!("output: {}", output);

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    receipt.verify(HELLO_GUEST_ID).unwrap();

    println!("receipt verify succeed");

    let verifier = extract_verifier(&receipt);
    println!("extract groth16: {}", verifier.is_ok());

    if verifier.is_ok() {
        let _ = groth16_verify(&verifier.unwrap());
    }
}

fn extract_verifier(receipt: &Receipt) -> Result<Groth16Verifier, VerificationError> {
    let ctx = VerifierContext::default();
    let params = ctx
        .groth16_verifier_parameters
        .as_ref()
        .ok_or(VerificationError::VerifierParametersMissing)?;

    if let InnerReceipt::Groth16(inner) = &receipt.inner {
        let (a0, a1) =
            split_digest(params.control_root).map_err(|_| VerificationError::ReceiptFormatError)?;
        let (c0, c1) = split_digest(inner.claim.digest::<sha::Impl>())
            .map_err(|_| VerificationError::ReceiptFormatError)?;
        let mut id_bn554: Digest = params.bn254_control_id;
        id_bn554.as_mut_bytes().reverse();
        let id_bn254_fr = fr_from_hex_string(&hex::encode(id_bn554))
            .map_err(|_| VerificationError::ReceiptFormatError)?;
        let verifier = Groth16Verifier::new(
            &Seal::from_vec(&inner.seal).map_err(|_| VerificationError::ReceiptFormatError)?,
            &[a0, a1, c0, c1, id_bn254_fr],
            &params.verifying_key,
        )
        .map_err(|_| VerificationError::ReceiptFormatError)?;
        Ok(verifier)
    } else {
        return Err(VerificationError::ReceiptFormatError);
    }
}

fn groth16_verify(verifier: &Groth16Verifier) -> bool {
    let risc0_verify = verifier.verify().is_ok();
    println!("risc0_verify: {}", risc0_verify);

    risc0_verify
}
